//+------------------------------------------------------------------+
//|                                     WolfeWaveScanner_D1Only.mq5 |
//|          Multi-Timeframe Scanner mit Mindestabstand             |
//+------------------------------------------------------------------+
#property copyright "Wolfe Wave Scanner"
#property version   "26.00"
#property description "M5 Support + Success Tracking"

//--- Input Parameter
input group "======= Scanner ======="
input int      InpScanIntervalMin = 15;          // Scan Intervall (Minuten)
input int      InpMaxSymbols      = 0;           // Max. Symbole (0=alle)
input int      InpScanBars        = 200;         // Bars to scan

input group "======= Timeframes ======="
input bool     InpScanM5          = true;        // M5 scannen
input bool     InpScanM15         = true;        // M15 scannen
input bool     InpScanH1          = true;        // H1 scannen
input bool     InpScanH4          = true;        // H4 scannen
input bool     InpScanD1          = true;        // D1 scannen
input bool     InpScanW1          = true;        // W1 scannen

input group "======= ZigZag ======="
input int      InpZZDepth         = 12;          // ZigZag Depth
input int      InpZZDeviation     = 5;           // ZigZag Deviation

input group "======= Wolfe Rules ======="
input int      InpMinBarsBetween  = 3;           // Min. Kerzen zwischen Punkten
input int      InpMaxBarsPattern  = 200;         // Max Bars for Pattern
input int      InpMaxBarsP5       = 10;          // Punkt 5 max. Bars alt
input double   InpP5Tolerance     = 0.15;        // P5 Toleranz zur Linie 1-3 (0.15 = 15%)
input double   InpMaxWedgeAngle   = 65.0;        // Max. Keil-Winkel in Grad

input group "======= Output ======="
input bool     InpDebugMode       = true;        // Debug Modus

//--- Strukturen
struct ZZPoint
{
   int      bar;
   double   price;
   datetime time;
   bool     isHigh;
};

struct WolfeWave
{
   string   symbol;
   ENUM_TIMEFRAMES timeframe;  // NEU: Timeframe
   ZZPoint  p1, p2, p3, p4, p5;
   bool     isBullish;
   double   entryPrice;
   double   slPrice;
   double   tpPrice;
   double   tp1Price;     // TP1: 33% zur grÃ¼nen Linie
   double   tp2Price;     // TP2: 66% zur grÃ¼nen Linie
   double   tp3Price;     // TP3: Ende der grÃ¼nen 1-4 Linie
   datetime epaTime;      // Kreuzungspunkt Zeit
   double   epaPrice;     // Kreuzungspunkt Preis
};

//--- Globale Variablen
datetime g_lastScanTime = 0;
int g_patternsFound = 0;
long g_openCharts[];

//--- Duplikat-Erkennung: speichert bereits gefundene Patterns
string g_foundPatterns[];  // Format: "SYMBOL_TF_P5TIME"
int g_maxStoredPatterns = 500;  // Max. gespeicherte Patterns

//+------------------------------------------------------------------+
//| Expert initialization                                             |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("============================================");
   Print("WOLFE WAVE SCANNER V26.00");
   Print("M5 SUPPORT + SUCCESS TRACKING");
   Print("Hotkeys: S=Scan, C=Close, T=Track Success");
   Print("============================================");
   Print("Min. Kerzen zwischen Punkten: ", InpMinBarsBetween);
   Print("P5 Toleranz zur Linie: ", InpP5Tolerance * 100, "%");
   Print("Punkt 5 max. ", InpMaxBarsP5, " Bars alt");
   Print("Max. Keil-Winkel: ", InpMaxWedgeAngle, "Â°");
   
   //--- Aktive Timeframes anzeigen
   string tfStr = "Timeframes: ";
   if(InpScanM5)  tfStr += "M5 ";
   if(InpScanM15) tfStr += "M15 ";
   if(InpScanH1)  tfStr += "H1 ";
   if(InpScanH4)  tfStr += "H4 ";
   if(InpScanD1)  tfStr += "D1 ";
   if(InpScanW1)  tfStr += "W1 ";
   Print(tfStr);
   
   //--- Hauptordner erstellen
   FolderCreate("WolfeWaves");
   
   //--- Pfad anzeigen
   string dataPath = TerminalInfoString(TERMINAL_DATA_PATH);
   Print("");
   Print("â˜…â˜…â˜… WEBSITE EXPORT ORDNER: â˜…â˜…â˜…");
   Print(dataPath + "\\MQL5\\Files\\WolfeWaves\\");
   Print("");
   Print("Struktur: /MARKT/TIMEFRAME/KEIL_ID/VERSIONEN");
   Print("");
   Print("  /WolfeWaves/");
   Print("    /DAX/");
   Print("      /H1/");
   Print("        /BULL_BMWGDE_20250113_1400/   <- Keil-Ordner");
   Print("          v_20250113_1500.png         <- Version 15:00");
   Print("          v_20250113_1515.png         <- Version 15:15");
   Print("          v_20250113_1530.png         <- Version 15:30");
   Print("          latest.png                  <- Aktuellste");
   Print("          latest.json                 <- Aktuellste Daten");
   Print("");
   Print("â–º Website zeigt: latest.png");
   Print("â–º Timeline: alle v_*.png zum ZurÃ¼ckspulen");
   Print("â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…");
   Print("");
   
   EventSetTimer(60);
   
   Print("Starte ersten Scan in 3 Sekunden...");
   Sleep(3000);
   PerformScan();
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   EventKillTimer();
   Print("Scanner beendet. Patterns: ", g_patternsFound);
}

//+------------------------------------------------------------------+
void OnTimer()
{
   if(TimeCurrent() - g_lastScanTime >= InpScanIntervalMin * 60)
      PerformScan();
   
   int mins = (int)((InpScanIntervalMin * 60 - (TimeCurrent() - g_lastScanTime)) / 60);
   Comment("Wolfe Multi-TF Scanner | Patterns: ", g_patternsFound, " | NÃ¤chster: ", mins, " Min | [S]=Scan");
}

//+------------------------------------------------------------------+
string TFToString(ENUM_TIMEFRAMES tf)
{
   switch(tf)
   {
      case PERIOD_M5:  return "M5";
      case PERIOD_M15: return "M15";
      case PERIOD_H1:  return "H1";
      case PERIOD_H4:  return "H4";
      case PERIOD_D1:  return "D1";
      case PERIOD_W1:  return "W1";
      default: return EnumToString(tf);
   }
}

//+------------------------------------------------------------------+
string GetMarket(string symbol)
{
   //--- Deutsche Aktien (DAX)
   if(StringFind(symbol, ".DE") >= 0) return "DAX";
   if(StringFind(symbol, "DE40") >= 0) return "DAX";
   if(StringFind(symbol, "GER40") >= 0) return "DAX";
   if(StringFind(symbol, "DAX") >= 0) return "DAX";
   
   //--- FranzÃ¶sische Aktien
   if(StringFind(symbol, ".PA") >= 0) return "CAC40";
   if(StringFind(symbol, "FRA40") >= 0) return "CAC40";
   
   //--- UK Aktien
   if(StringFind(symbol, ".UK") >= 0) return "FTSE";
   if(StringFind(symbol, ".L") >= 0) return "FTSE";
   if(StringFind(symbol, "UK100") >= 0) return "FTSE";
   
   //--- Niederlande
   if(StringFind(symbol, ".AS") >= 0) return "AEX";
   
   //--- Spanien
   if(StringFind(symbol, ".MC") >= 0) return "IBEX";
   
   //--- Schweiz
   if(StringFind(symbol, ".SW") >= 0) return "SMI";
   
   //--- NASDAQ Aktien (Einzelwerte)
   if(StringFind(symbol, ".OQ") >= 0) return "NASDAQ";  // z.B. VRSN.OQ, AAPL.OQ
   if(StringFind(symbol, ".O") >= 0) return "NASDAQ";   // Alternative Endung
   
   //--- NYSE Aktien
   if(StringFind(symbol, ".N") >= 0) return "NYSE";     // z.B. MA.N (Mastercard)
   if(StringFind(symbol, ".K") >= 0) return "NYSE";     // Alternative
   
   //--- Indices
   if(StringFind(symbol, "US500") >= 0) return "SP500";
   if(StringFind(symbol, "US100") >= 0) return "NASDAQ";
   if(StringFind(symbol, "US30") >= 0) return "DOWJONES";
   if(StringFind(symbol, "USTEC") >= 0) return "NASDAQ";
   if(StringFind(symbol, "SPX") >= 0) return "SP500";
   if(StringFind(symbol, "NDX") >= 0) return "NASDAQ";
   
   //--- Forex
   if(StringFind(symbol, "USD") >= 0 || StringFind(symbol, "EUR") >= 0 ||
      StringFind(symbol, "GBP") >= 0 || StringFind(symbol, "JPY") >= 0 ||
      StringFind(symbol, "CHF") >= 0 || StringFind(symbol, "AUD") >= 0 ||
      StringFind(symbol, "CAD") >= 0 || StringFind(symbol, "NZD") >= 0)
   {
      if(StringLen(symbol) == 6 || StringFind(symbol, ".") < 0)
         return "FOREX";
   }
   
   //--- US Aktien (Default fÃ¼r amerikanische Symbole)
   if(StringFind(symbol, ".US") >= 0) return "USA";
   if(StringFind(symbol, ".") < 0) return "USA";  // Kein Suffix = USA
   
   //--- Unbekannt
   return "OTHER";
}

//+------------------------------------------------------------------+
string GetPatternKey(WolfeWave &wave)
{
   //--- Eindeutiger SchlÃ¼ssel fÃ¼r ein Pattern
   //--- NUR P1-P4 verwenden (die Ã¤ndern sich nicht mehr!)
   //--- P5 Ã¤ndert sich stÃ¤ndig wÃ¤hrend Kerze lÃ¤uft
   //--- Format: SYMBOL_TF_P1TIME_P4TIME
   return wave.symbol + "_" + TFToString(wave.timeframe) + "_" + 
          IntegerToString((long)wave.p1.time) + "_" +
          IntegerToString((long)wave.p4.time);
}

//+------------------------------------------------------------------+
bool IsPatternDuplicate(WolfeWave &wave)
{
   string key = GetPatternKey(wave);
   
   //--- PrÃ¼fen ob Pattern bereits gefunden wurde
   for(int i = 0; i < ArraySize(g_foundPatterns); i++)
   {
      if(g_foundPatterns[i] == key)
         return true;  // Duplikat - aber wir ÃœBERSCHREIBEN!
   }
   
   return false;  // Neu!
}

//+------------------------------------------------------------------+
void AddPatternToHistory(WolfeWave &wave)
{
   string key = GetPatternKey(wave);
   
   int size = ArraySize(g_foundPatterns);
   
   //--- Wenn zu viele gespeichert, Ã¤lteste entfernen
   if(size >= g_maxStoredPatterns)
   {
      //--- Erste 100 entfernen (FIFO)
      for(int i = 0; i < size - 100; i++)
         g_foundPatterns[i] = g_foundPatterns[i + 100];
      ArrayResize(g_foundPatterns, size - 100);
      size = ArraySize(g_foundPatterns);
   }
   
   //--- Neues Pattern hinzufÃ¼gen
   ArrayResize(g_foundPatterns, size + 1);
   g_foundPatterns[size] = key;
}

//+------------------------------------------------------------------+
void PerformScan()
{
   Print("");
   Print("========== MULTI-TF SCAN ==========");
   g_lastScanTime = TimeCurrent();
   
   //--- Timeframes sammeln
   ENUM_TIMEFRAMES timeframes[];
   int tfCount = 0;
   
   if(InpScanM5)  { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_M5; }
   if(InpScanM15) { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_M15; }
   if(InpScanH1)  { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_H1; }
   if(InpScanH4)  { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_H4; }
   if(InpScanD1)  { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_D1; }
   if(InpScanW1)  { ArrayResize(timeframes, tfCount+1); timeframes[tfCount++] = PERIOD_W1; }
   
   if(tfCount == 0)
   {
      Print("Kein Timeframe ausgewÃ¤hlt!");
      return;
   }
   
   int totalSymbols = SymbolsTotal(true);
   int toScan = (InpMaxSymbols > 0) ? MathMin(InpMaxSymbols, totalSymbols) : totalSymbols;
   
   Print("Scanne ", toScan, " Symbole x ", tfCount, " Timeframes...");
   
   int foundThisScan = 0;
   
   for(int s = 0; s < toScan; s++)
   {
      string symbol = SymbolName(s, true);
      
      if(!SymbolInfoInteger(symbol, SYMBOL_VISIBLE))
         continue;
      
      //--- Alle Timeframes fÃ¼r dieses Symbol scannen
      for(int t = 0; t < tfCount; t++)
      {
         WolfeWave wave;
         if(ScanSymbol(symbol, timeframes[t], wave))
         {
            //--- DUPLIKAT-CHECK: Gleiches Pattern schon gefunden?
            bool isUpdate = IsPatternDuplicate(wave);
            
            if(isUpdate)
            {
               if(InpDebugMode)
                  Print("  ðŸ”„ Update: ", symbol, " ", TFToString(timeframes[t]), " (Bild wird Ã¼berschrieben)");
            }
            else
            {
               //--- Neues Pattern! Zur History hinzufÃ¼gen
               AddPatternToHistory(wave);
               g_patternsFound++;
            }
            
            foundThisScan++;
            
            Print("");
            Print(isUpdate ? "ðŸ”„ WOLFE WAVE UPDATE ðŸ”„" : "â˜…â˜…â˜… NEUES WOLFE WAVE â˜…â˜…â˜…");
            Print("Symbol: ", symbol, " ", TFToString(timeframes[t]));
            Print("Typ: ", wave.isBullish ? "BULLISH" : "BEARISH");
            Print("P1: ", DoubleToString(wave.p1.price, 2), " @ ", TimeToString(wave.p1.time));
            Print("P2: ", DoubleToString(wave.p2.price, 2), " @ ", TimeToString(wave.p2.time));
            Print("P3: ", DoubleToString(wave.p3.price, 2), " @ ", TimeToString(wave.p3.time));
            Print("P4: ", DoubleToString(wave.p4.price, 2), " @ ", TimeToString(wave.p4.time));
            Print("P5: ", DoubleToString(wave.p5.price, 2), " @ ", TimeToString(wave.p5.time));
            Print("Entry: ", DoubleToString(wave.entryPrice, 2));
            Print("SL: ", DoubleToString(wave.slPrice, 2));
            Print("TP1: ", DoubleToString(wave.tp1Price, 2));
            Print("TP2: ", DoubleToString(wave.tp2Price, 2));
            Print("TP3: ", DoubleToString(wave.tp3Price, 2));
            Print(isUpdate ? "ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„ðŸ”„" : "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…");
            
            OpenAndDrawChart(wave);
         }
      }
      
      Sleep(50);
      
      if(s > 0 && s % 25 == 0)
         Print("... ", s, "/", toScan);
   }
   
   Print("");
   Print("========== SCAN ENDE ==========");
   Print("Gefunden: ", foundThisScan);
   Print("Gesamt: ", g_patternsFound);
}

//+------------------------------------------------------------------+
bool ScanSymbol(string symbol, ENUM_TIMEFRAMES tf, WolfeWave &wave)
{
   MqlRates rates[];
   ArraySetAsSeries(rates, true);
   
   int copied = CopyRates(symbol, tf, 0, InpScanBars, rates);
   if(copied < 50)
      return false;
   
   ZZPoint zzPoints[];
   CalculateZigZag(rates, copied, zzPoints);
   
   if(ArraySize(zzPoints) < 5)
      return false;
   
   wave.symbol = symbol;
   wave.timeframe = tf;
   
   if(FindWolfeWave(zzPoints, rates, wave))
   {
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
void CalculateZigZag(MqlRates &rates[], int count, ZZPoint &zzPoints[])
{
   ArrayResize(zzPoints, 0);
   
   double zigzag[];
   int direction[];
   ArrayResize(zigzag, count);
   ArrayResize(direction, count);
   ArrayInitialize(zigzag, 0);
   ArrayInitialize(direction, 0);
   
   double lastHigh = 0, lastLow = 0;
   int lastHighBar = -1, lastLowBar = -1;
   int trend = 0;
   
   for(int i = count - InpZZDepth - 1; i >= 0; i--)
   {
      int highestBar = i;
      double highestVal = rates[i].high;
      for(int j = 1; j < InpZZDepth && i + j < count; j++)
      {
         if(rates[i + j].high > highestVal)
         {
            highestVal = rates[i + j].high;
            highestBar = i + j;
         }
      }
      
      int lowestBar = i;
      double lowestVal = rates[i].low;
      for(int j = 1; j < InpZZDepth && i + j < count; j++)
      {
         if(rates[i + j].low < lowestVal)
         {
            lowestVal = rates[i + j].low;
            lowestBar = i + j;
         }
      }
      
      if(highestBar == i)
      {
         if(trend != 1)
         {
            trend = 1;
            lastHigh = rates[i].high;
            lastHighBar = i;
            zigzag[i] = rates[i].high;
            direction[i] = 1;
         }
         else if(rates[i].high > lastHigh)
         {
            if(lastHighBar >= 0) zigzag[lastHighBar] = 0;
            lastHigh = rates[i].high;
            lastHighBar = i;
            zigzag[i] = rates[i].high;
            direction[i] = 1;
         }
      }
      
      if(lowestBar == i)
      {
         if(trend != -1)
         {
            trend = -1;
            lastLow = rates[i].low;
            lastLowBar = i;
            zigzag[i] = rates[i].low;
            direction[i] = -1;
         }
         else if(rates[i].low < lastLow)
         {
            if(lastLowBar >= 0) zigzag[lastLowBar] = 0;
            lastLow = rates[i].low;
            lastLowBar = i;
            zigzag[i] = rates[i].low;
            direction[i] = -1;
         }
      }
   }
   
   for(int i = 0; i < count; i++)
   {
      if(zigzag[i] != 0)
      {
         ZZPoint point;
         point.bar = i;
         point.price = zigzag[i];
         point.time = rates[i].time;
         point.isHigh = (direction[i] > 0);
         
         int size = ArraySize(zzPoints);
         ArrayResize(zzPoints, size + 1);
         zzPoints[size] = point;
         
         if(size >= 12) break;
      }
   }
}

//+------------------------------------------------------------------+
bool FindWolfeWave(ZZPoint &zzPoints[], MqlRates &rates[], WolfeWave &wave)
{
   int count = ArraySize(zzPoints);
   
   for(int start = 0; start <= count - 5; start++)
   {
      ZZPoint pts[5];
      for(int i = 0; i < 5; i++)
         pts[i] = zzPoints[start + i];
      
      if(pts[4].bar - pts[0].bar > InpMaxBarsPattern)
         continue;
      
      //--- Mindestens X Kerzen zwischen jedem Punkt (P5â†’P4â†’P3â†’P2â†’P1)
      //--- pts[0]=P5, pts[1]=P4, pts[2]=P3, pts[3]=P2, pts[4]=P1
      int bars54 = pts[1].bar - pts[0].bar;  // P5 zu P4
      int bars43 = pts[2].bar - pts[1].bar;  // P4 zu P3
      int bars32 = pts[3].bar - pts[2].bar;  // P3 zu P2
      int bars21 = pts[4].bar - pts[3].bar;  // P2 zu P1
      
      if(bars54 < InpMinBarsBetween || bars43 < InpMinBarsBetween ||
         bars32 < InpMinBarsBetween || bars21 < InpMinBarsBetween)
         continue;
      
      // Bullish: L-H-L-H-L
      if(!pts[0].isHigh && pts[1].isHigh && !pts[2].isHigh && 
          pts[3].isHigh && !pts[4].isHigh)
      {
         if(ValidateBullish(pts, rates, wave))
            return true;
      }
      
      // Bearish: H-L-H-L-H
      if(pts[0].isHigh && !pts[1].isHigh && pts[2].isHigh && 
         !pts[3].isHigh && pts[4].isHigh)
      {
         if(ValidateBearish(pts, rates, wave))
            return true;
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| BULLISH Validierung mit Konvergenz-Check                         |
//+------------------------------------------------------------------+
bool ValidateBullish(ZZPoint &pts[], MqlRates &rates[], WolfeWave &wave)
{
   //--- Punkt 5 muss aktuell sein!
   if(pts[0].bar > InpMaxBarsP5)
      return false;
   
   //=== P5 MUSS AUF GESCHLOSSENER KERZE SEIN ===
   // Bar 0 = aktuelle (laufende) Kerze - nicht erlaubt!
   if(pts[0].bar < 1)
      return false;
   
   double p1 = pts[4].price;
   double p2 = pts[3].price;
   double p3 = pts[2].price;
   double p4 = pts[1].price;
   double p5 = pts[0].price;
   
   datetime t1 = pts[4].time;
   datetime t2 = pts[3].time;
   datetime t3 = pts[2].time;
   datetime t4 = pts[1].time;
   datetime t5 = pts[0].time;
   
   //=== P5 BESTÃ„TIGUNG: NÃ¤chste Kerze muss ÃœBER P5 schlieÃŸen ===
   // pts[0].bar ist die P5-Kerze, pts[0].bar - 1 ist die Kerze danach
   int confirmBar = pts[0].bar - 1;
   if(confirmBar >= 0)
   {
      double confirmClose = rates[confirmBar].close;
      if(confirmClose <= p5)
         return false;  // Kerze hat nicht Ã¼ber P5 geschlossen - keine BestÃ¤tigung!
   }
   
   //=== GRUNDREGELN ===
   if(p3 >= p1) return false;  // P3 muss tiefer als P1
   if(p4 >= p2) return false;  // P4 muss tiefer als P2
   if(p4 <= p1 || p4 <= p3) return false;  // P4 muss Ã¼ber P1 und P3
   
   //=== PREIS-ALTERNIERUNG PRÃœFEN (Bullish: L-H-L-H-L) ===
   // P2 (High) > P1 (Low)
   if(p2 <= p1) return false;
   // P2 (High) > P3 (Low)
   if(p2 <= p3) return false;
   // P4 (High) > P3 (Low)
   if(p4 <= p3) return false;
   // P4 (High) > P5 (Low)
   if(p4 <= p5) return false;
   
   //=== KEIL-WINKEL PRÃœFEN ===
   // Normalisierter Winkel basierend auf Pattern-HÃ¶he
   double patternHeight = MathAbs(p2 - p3);
   if(patternHeight < 0.0001) return false;  // Zu flaches Pattern
   
   int bars13 = pts[2].bar - pts[4].bar;  // Bars zwischen P1 und P3
   if(bars13 < 1) bars13 = 1;
   
   // Steigung normalisiert: PreisÃ¤nderung pro Bar, relativ zur Pattern-HÃ¶he
   double priceChange13 = MathAbs(p3 - p1);
   double normalizedSlope = (priceChange13 / patternHeight) / (bars13 / 10.0);
   double angle13 = MathArctan(normalizedSlope) * 180.0 / M_PI;
   
   if(angle13 > InpMaxWedgeAngle)
      return false;  // Keil zu steil!
   
   //=== P5 MUSS AUF LINIE 1-3 LIEGEN ===
   // Berechne wo Linie 1-3 bei Zeit t5 wÃ¤re
   double slope13 = (p3 - p1) / (double)(t3 - t1);
   double expectedP5 = p1 + slope13 * (double)(t5 - t1);
   
   // P5 darf max X% der Pattern-HÃ¶he von der Linie abweichen
   double tolerance = patternHeight * InpP5Tolerance;
   
   if(MathAbs(p5 - expectedP5) > tolerance)
      return false;  // P5 ist nicht auf der Trendlinie 1-3!
   
   //=== SWEET ZONE CHECK - DEAKTIVIERT ===
   // Strecke 2â†’3 auf P4 dupliziert = erwartete Zone fÃ¼r P5
   // double strecke23 = MathAbs(p2 - p3);
   // double sweetZoneTop = p4;
   // double sweetZoneBottom = p4 - strecke23;
   // if(p5 > sweetZoneTop || p5 < sweetZoneBottom)
   //    return false;
   
   //=== SLOPES BERECHNEN ===
   double slope24 = (p4 - p2) / (double)(t4 - t2);
   
   //=== KONVERGENZ-CHECK ===
   double b13 = p1 - slope13 * (double)t1;
   double b24 = p2 - slope24 * (double)t2;
   
   double slopeDiff = slope13 - slope24;
   if(MathAbs(slopeDiff) < 0.0000000001) 
      return false;  // Parallel
   
   double tCross = (b24 - b13) / slopeDiff;
   
   if(tCross <= (double)t5)
      return false;  // Kreuzung in Vergangenheit
   
   double pCross = slope13 * tCross + b13;
   
   if(pCross <= p5)
      return false;  // EPA muss Ã¼ber P5
   
   //=== KURSZIELE BERECHNEN ===
   double slope14 = (p4 - p1) / (double)(t4 - t1);
   
   // Keil-Dauer fÃ¼r grÃ¼ne Linie (2x Keil-LÃ¤nge)
   int keilDauer = (int)(t5 - t1);
   datetime greenEnd = t4 + keilDauer;
   
   // TP3 = Preis auf 1-4 Linie am Ende der grÃ¼nen Linie
   double tp3OnLine = p1 + slope14 * (double)(greenEnd - t1);
   
   //=== SL BERECHNEN: 15% unter P5 ===
   double slPrice = p5 - patternHeight * 0.15;
   
   //=== TP BERECHNEN: Klassische Staffelung zum Ende der 1-4 Linie ===
   double tpRange = tp3OnLine - p5;
   double tp1Calc = p5 + tpRange * 0.33;  // 33%
   double tp2Calc = p5 + tpRange * 0.66;  // 66%
   double tp3Calc = tp3OnLine;             // 100% = Ende der grÃ¼nen Linie
   
   //=== PATTERN IST GÃœLTIG! ===
   wave.p1 = pts[4];
   wave.p2 = pts[3];
   wave.p3 = pts[2];
   wave.p4 = pts[1];
   wave.p5 = pts[0];
   wave.isBullish = true;
   wave.entryPrice = p5;
   wave.slPrice = slPrice;
   wave.tpPrice = pCross;
   wave.tp1Price = tp1Calc;
   wave.tp2Price = tp2Calc;
   wave.tp3Price = tp3Calc;
   wave.epaTime = (datetime)tCross;
   wave.epaPrice = pCross;
   
   return true;
}

//+------------------------------------------------------------------+
//| BEARISH Validierung mit Konvergenz-Check                         |
//+------------------------------------------------------------------+
bool ValidateBearish(ZZPoint &pts[], MqlRates &rates[], WolfeWave &wave)
{
   //--- Punkt 5 muss aktuell sein!
   if(pts[0].bar > InpMaxBarsP5)
      return false;
   
   //=== P5 MUSS AUF GESCHLOSSENER KERZE SEIN ===
   // Bar 0 = aktuelle (laufende) Kerze - nicht erlaubt!
   if(pts[0].bar < 1)
      return false;
   
   double p1 = pts[4].price;
   double p2 = pts[3].price;
   double p3 = pts[2].price;
   double p4 = pts[1].price;
   double p5 = pts[0].price;
   
   datetime t1 = pts[4].time;
   datetime t2 = pts[3].time;
   datetime t3 = pts[2].time;
   datetime t4 = pts[1].time;
   datetime t5 = pts[0].time;
   
   //=== P5 BESTÃ„TIGUNG: NÃ¤chste Kerze muss UNTER P5 schlieÃŸen ===
   // pts[0].bar ist die P5-Kerze, pts[0].bar - 1 ist die Kerze danach
   int confirmBar = pts[0].bar - 1;
   if(confirmBar >= 0)
   {
      double confirmClose = rates[confirmBar].close;
      if(confirmClose >= p5)
         return false;  // Kerze hat nicht unter P5 geschlossen - keine BestÃ¤tigung!
   }
   
   //=== GRUNDREGELN ===
   if(p3 <= p1) return false;  // P3 muss hÃ¶her als P1
   if(p4 <= p2) return false;  // P4 muss hÃ¶her als P2
   if(p4 >= p1 || p4 >= p3) return false;  // P4 muss unter P1 und P3
   
   //=== PREIS-ALTERNIERUNG PRÃœFEN (Bearish: H-L-H-L-H) ===
   // P1 (High) > P2 (Low)
   if(p1 <= p2) return false;
   // P3 (High) > P2 (Low)
   if(p3 <= p2) return false;
   // P3 (High) > P4 (Low)
   if(p3 <= p4) return false;
   // P5 (High) > P4 (Low)
   if(p5 <= p4) return false;
   
   //=== KEIL-WINKEL PRÃœFEN ===
   // Normalisierter Winkel basierend auf Pattern-HÃ¶he
   double patternHeight = MathAbs(p3 - p2);
   if(patternHeight < 0.0001) return false;  // Zu flaches Pattern
   
   int bars13 = pts[2].bar - pts[4].bar;  // Bars zwischen P1 und P3
   if(bars13 < 1) bars13 = 1;
   
   // Steigung normalisiert: PreisÃ¤nderung pro Bar, relativ zur Pattern-HÃ¶he
   double priceChange13 = MathAbs(p3 - p1);
   double normalizedSlope = (priceChange13 / patternHeight) / (bars13 / 10.0);
   double angle13 = MathArctan(normalizedSlope) * 180.0 / M_PI;
   
   if(angle13 > InpMaxWedgeAngle)
      return false;  // Keil zu steil!
   
   //=== P5 MUSS AUF LINIE 1-3 LIEGEN ===
   // Berechne wo Linie 1-3 bei Zeit t5 wÃ¤re
   double slope13 = (p3 - p1) / (double)(t3 - t1);
   double expectedP5 = p1 + slope13 * (double)(t5 - t1);
   
   // P5 darf max X% der Pattern-HÃ¶he von der Linie abweichen
   double tolerance = patternHeight * InpP5Tolerance;
   
   if(MathAbs(p5 - expectedP5) > tolerance)
      return false;  // P5 ist nicht auf der Trendlinie 1-3!
   
   //=== SWEET ZONE CHECK - DEAKTIVIERT ===
   // Strecke 2â†’3 auf P4 dupliziert = erwartete Zone fÃ¼r P5
   // double strecke23 = MathAbs(p3 - p2);
   // double sweetZoneBottom = p4;
   // double sweetZoneTop = p4 + strecke23;
   // if(p5 < sweetZoneBottom || p5 > sweetZoneTop)
   //    return false;
   
   //=== SLOPES BERECHNEN ===
   double slope24 = (p4 - p2) / (double)(t4 - t2);
   
   //=== KONVERGENZ-CHECK ===
   double b13 = p1 - slope13 * (double)t1;
   double b24 = p2 - slope24 * (double)t2;
   
   double slopeDiff = slope13 - slope24;
   if(MathAbs(slopeDiff) < 0.0000000001) 
      return false;  // Parallel
   
   double tCross = (b24 - b13) / slopeDiff;
   
   if(tCross <= (double)t5)
      return false;  // Kreuzung in Vergangenheit
   
   double pCross = slope13 * tCross + b13;
   
   if(pCross >= p5)
      return false;  // EPA muss unter P5
   
   //=== KURSZIELE BERECHNEN ===
   double slope14 = (p4 - p1) / (double)(t4 - t1);
   
   // Keil-Dauer fÃ¼r grÃ¼ne Linie (2x Keil-LÃ¤nge)
   int keilDauer = (int)(t5 - t1);
   datetime greenEnd = t4 + keilDauer;
   
   // TP3 = Preis auf 1-4 Linie am Ende der grÃ¼nen Linie
   double tp3OnLine = p1 + slope14 * (double)(greenEnd - t1);
   
   //=== SL BERECHNEN: 15% Ã¼ber P5 ===
   double slPrice = p5 + patternHeight * 0.15;
   
   //=== TP BERECHNEN: Klassische Staffelung zum Ende der 1-4 Linie ===
   double tpRange = p5 - tp3OnLine;  // Bearish: Entry - Target
   double tp1Calc = p5 - tpRange * 0.33;  // 33%
   double tp2Calc = p5 - tpRange * 0.66;  // 66%
   double tp3Calc = tp3OnLine;             // 100% = Ende der grÃ¼nen Linie
   
   //=== PATTERN IST GÃœLTIG! ===
   wave.p1 = pts[4];
   wave.p2 = pts[3];
   wave.p3 = pts[2];
   wave.p4 = pts[1];
   wave.p5 = pts[0];
   wave.isBullish = false;
   wave.entryPrice = p5;
   wave.slPrice = slPrice;
   wave.tpPrice = pCross;
   wave.tp1Price = tp1Calc;
   wave.tp2Price = tp2Calc;
   wave.tp3Price = tp3Calc;
   wave.epaTime = (datetime)tCross;
   wave.epaPrice = pCross;
   
   return true;
}

//+------------------------------------------------------------------+
void OpenAndDrawChart(WolfeWave &wave)
{
   Print("Ã–ffne Chart fÃ¼r ", wave.symbol, " ", TFToString(wave.timeframe), "...");
   
   long chartId = ChartOpen(wave.symbol, wave.timeframe);
   
   if(chartId == 0)
   {
      Print("FEHLER: Chart konnte nicht geÃ¶ffnet werden!");
      return;
   }
   
   //--- Max 10 Charts offen - Ã¤ltesten schlieÃŸen wenn voll
   int size = ArraySize(g_openCharts);
   if(size >= 10)
   {
      ChartClose(g_openCharts[0]);  // Ã„ltesten schlieÃŸen
      // Array nach links shiften
      for(int i = 0; i < size - 1; i++)
         g_openCharts[i] = g_openCharts[i + 1];
      ArrayResize(g_openCharts, size - 1);
      size = size - 1;
   }
   ArrayResize(g_openCharts, size + 1);
   g_openCharts[size] = chartId;
   
   //--- Chart konfigurieren
   ChartSetInteger(chartId, CHART_MODE, CHART_CANDLES);
   ChartSetInteger(chartId, CHART_SHOW_GRID, false);
   ChartSetInteger(chartId, CHART_AUTOSCROLL, false);
   ChartSetInteger(chartId, CHART_SHIFT, true);
   ChartSetDouble(chartId, CHART_SHIFT_SIZE, 30.0);  // 30% Platz rechts (weniger = mehr Keil sichtbar)
   ChartSetInteger(chartId, CHART_SHOW_VOLUMES, CHART_VOLUME_HIDE);  // Volumen ausblenden
   
   //--- ZOOM: Weiter rausgezoomt (Scale 0-5, niedriger = mehr Kerzen sichtbar)
   ChartSetInteger(chartId, CHART_SCALE, 3);  // 3 = mehr reingezoomt
   
   //--- WeiÃŸer Hintergrund
   ChartSetInteger(chartId, CHART_COLOR_BACKGROUND, clrWhite);
   ChartSetInteger(chartId, CHART_COLOR_FOREGROUND, clrBlack);
   ChartSetInteger(chartId, CHART_COLOR_GRID, clrWhite);  // Grid ausblenden
   
   //--- KERZEN: Schwarz/WeiÃŸ Stil - KEINE grÃ¼nen Kerzen!
   ChartSetInteger(chartId, CHART_COLOR_CANDLE_BULL, clrWhite);     // Bullish KÃ¶rper: WeiÃŸ
   ChartSetInteger(chartId, CHART_COLOR_CHART_UP, clrBlack);        // Bullish Rand/Docht: Schwarz
   ChartSetInteger(chartId, CHART_COLOR_CANDLE_BEAR, clrBlack);     // Bearish KÃ¶rper: Schwarz
   ChartSetInteger(chartId, CHART_COLOR_CHART_DOWN, clrBlack);      // Bearish Rand/Docht: Schwarz
   ChartSetInteger(chartId, CHART_COLOR_CHART_LINE, clrBlack);      // Linie: Schwarz
   
   //--- Farben sofort anwenden
   ChartRedraw(chartId);
   Sleep(200);
   
   //--- Pattern 3/4 RECHTS positionieren
   int patternStart = wave.p1.bar;  // Ã„ltester Punkt
   int shift = patternStart - 10;   // Pattern fast am rechten Rand, 10 Bars Puffer
   if(shift < 0) shift = 0;
   ChartNavigate(chartId, CHART_END, -shift);
   
   Sleep(1000);
   ChartRedraw(chartId);
   Sleep(500);
   
   DrawPatternOnChart(chartId, wave);
   
   ChartRedraw(chartId);
   Sleep(500);
   
   //--- Screenshot - MIT ORDNERSTRUKTUR FÃœR WEBSITE
   string symbolClean = wave.symbol;
   StringReplace(symbolClean, ".", "");
   StringReplace(symbolClean, "/", "");
   
   MqlDateTime dtP4;
   TimeToStruct(wave.p4.time, dtP4);  // P4 Zeit fÃ¼r Keil-ID
   
   MqlDateTime dtNow;
   TimeCurrent(dtNow);  // Aktuelle Zeit fÃ¼r Version
   
   //--- MARKT ERKENNEN
   string market = GetMarket(wave.symbol);
   string tfStr = TFToString(wave.timeframe);
   
   //--- Keil-ID basiert auf P4-Zeit
   string p4DateStr = StringFormat("%04d%02d%02d_%02d%02d", 
                       dtP4.year, dtP4.mon, dtP4.day, dtP4.hour, dtP4.min);
   string typeStr = wave.isBullish ? "BULL" : "BEAR";
   string wedgeId = typeStr + "_" + symbolClean + "_" + p4DateStr;
   
   //--- Ordnerstruktur: WolfeWaves/MARKT/TIMEFRAME/KEIL_ID/
   //--- z.B. WolfeWaves/DAX/H1/BULL_BMWGDE_20250113_1400/
   string baseFolder = "WolfeWaves\\" + market + "\\" + tfStr + "\\" + wedgeId + "\\";
   
   //--- Dateiname = aktuelle Zeit (Version)
   string versionStr = StringFormat("%04d%02d%02d_%02d%02d", 
                        dtNow.year, dtNow.mon, dtNow.day, dtNow.hour, dtNow.min);
   
   //--- Format: v_20250113_1530.png (Version/Snapshot)
   string baseName = "v_" + versionStr;
   string pngFile = baseFolder + baseName + ".png";
   string jsonFile = baseFolder + baseName + ".json";
   
   //--- "latest" Symlink-Ã¤hnlich: auch aktuelles Bild als latest.png speichern
   string latestPng = baseFolder + "latest.png";
   string latestJson = baseFolder + "latest.json";
   
   //--- Ordner erstellen (falls nicht existiert)
   FolderCreate("WolfeWaves");
   FolderCreate("WolfeWaves\\" + market);
   FolderCreate("WolfeWaves\\" + market + "\\" + tfStr);
   FolderCreate("WolfeWaves\\" + market + "\\" + tfStr + "\\" + wedgeId);
   
   //--- JSON Metadaten fÃ¼r Website speichern
   string symbolName = SymbolInfoString(wave.symbol, SYMBOL_DESCRIPTION);
   if(symbolName == "") symbolName = wave.symbol;
   
   string dateFolder = StringFormat("%04d-%02d-%02d", dtNow.year, dtNow.mon, dtNow.day);
   
   //--- Prozent und RR berechnen
   double slPct = ((wave.slPrice - wave.entryPrice) / wave.entryPrice) * 100;
   double tp1Pct = ((wave.tp1Price - wave.entryPrice) / wave.entryPrice) * 100;
   double tp2Pct = ((wave.tp2Price - wave.entryPrice) / wave.entryPrice) * 100;
   double tp3Pct = ((wave.tp3Price - wave.entryPrice) / wave.entryPrice) * 100;
   double risk = MathAbs(wave.entryPrice - wave.slPrice);
   double reward = MathAbs(wave.tp1Price - wave.entryPrice);
   double rr = (risk > 0) ? reward / risk : 0;
   
   string json = "{\n";
   json += "  \"symbol\": \"" + wave.symbol + "\",\n";
   json += "  \"symbolName\": \"" + symbolName + "\",\n";
   json += "  \"market\": \"" + market + "\",\n";
   json += "  \"timeframe\": \"" + tfStr + "\",\n";
   json += "  \"type\": \"" + typeStr + "\",\n";
   json += "  \"direction\": \"" + (wave.isBullish ? "BULLISH" : "BEARISH") + "\",\n";
   json += "  \"date\": \"" + dateFolder + "\",\n";
   json += "  \"timestamp\": \"" + TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + "\",\n";
   json += "  \"version\": \"" + versionStr + "\",\n";
   json += "  \"entry\": " + DoubleToString(wave.entryPrice, 4) + ",\n";
   json += "  \"sl\": " + DoubleToString(wave.slPrice, 4) + ",\n";
   json += "  \"slPct\": " + DoubleToString(slPct, 2) + ",\n";
   json += "  \"tp1\": " + DoubleToString(wave.tp1Price, 4) + ",\n";
   json += "  \"tp1Pct\": " + DoubleToString(tp1Pct, 2) + ",\n";
   json += "  \"tp2\": " + DoubleToString(wave.tp2Price, 4) + ",\n";
   json += "  \"tp2Pct\": " + DoubleToString(tp2Pct, 2) + ",\n";
   json += "  \"tp3\": " + DoubleToString(wave.tp3Price, 4) + ",\n";
   json += "  \"tp3Pct\": " + DoubleToString(tp3Pct, 2) + ",\n";
   json += "  \"rr\": " + DoubleToString(rr, 2) + ",\n";
   json += "  \"p1\": { \"price\": " + DoubleToString(wave.p1.price, 4) + ", \"time\": \"" + TimeToString(wave.p1.time) + "\" },\n";
   json += "  \"p2\": { \"price\": " + DoubleToString(wave.p2.price, 4) + ", \"time\": \"" + TimeToString(wave.p2.time) + "\" },\n";
   json += "  \"p3\": { \"price\": " + DoubleToString(wave.p3.price, 4) + ", \"time\": \"" + TimeToString(wave.p3.time) + "\" },\n";
   json += "  \"p4\": { \"price\": " + DoubleToString(wave.p4.price, 4) + ", \"time\": \"" + TimeToString(wave.p4.time) + "\" },\n";
   json += "  \"p5\": { \"price\": " + DoubleToString(wave.p5.price, 4) + ", \"time\": \"" + TimeToString(wave.p5.time) + "\" },\n";
   json += "  \"wedgeId\": \"" + wedgeId + "\",\n";
   json += "  \"image\": \"" + baseName + ".png\",\n";
   json += "  \"path\": \"" + market + "/" + tfStr + "/" + wedgeId + "/" + baseName + ".png\"\n";
   json += "}";
   
   //--- JSON speichern (Version)
   int jsonHandle = FileOpen(jsonFile, FILE_WRITE|FILE_TXT|FILE_ANSI);
   if(jsonHandle != INVALID_HANDLE)
   {
      FileWriteString(jsonHandle, json);
      FileClose(jsonHandle);
   }
   
   //--- JSON auch als latest.json speichern (Ã¼berschreibt)
   int latestHandle = FileOpen(latestJson, FILE_WRITE|FILE_TXT|FILE_ANSI);
   if(latestHandle != INVALID_HANDLE)
   {
      FileWriteString(latestHandle, json);
      FileClose(latestHandle);
   }
   
   //--- Voller Pfad anzeigen
   string dataPath = TerminalInfoString(TERMINAL_DATA_PATH);
   Print("");
   Print("Speichere Screenshot...");
   Print("Keil: ", wedgeId);
   Print("Version: ", versionStr);
   Print("Ordner: ", baseFolder);
   
   //--- LÃ¤ngere Wartezeit damit Chart fertig ist
   Sleep(1000);
   ChartRedraw(chartId);
   Sleep(500);
   
   //--- Screenshot als Version speichern
   if(ChartScreenShot(chartId, pngFile, 1920, 1080, ALIGN_RIGHT))
   {
      Print("âœ“ Version gespeichert: ", baseName, ".png");
      
      //--- Auch als latest.png speichern (fÃ¼r schnellen Zugriff)
      if(ChartScreenShot(chartId, latestPng, 1920, 1080, ALIGN_RIGHT))
         Print("âœ“ Latest aktualisiert: latest.png");
   }
   else
   {
      int err = GetLastError();
      Print("âœ— Screenshot Fehler Code: ", err);
   }
   
   Print("âœ“âœ“âœ“ FERTIG âœ“âœ“âœ“");
   PlaySound("alert.wav");
}

//+------------------------------------------------------------------+
void DrawPatternOnChart(long chartId, WolfeWave &wave)
{
   string prefix = "WW_" + wave.symbol + "_";
   color waveColor = clrRed;
   
   //--- BERECHNE ENDPUNKTE FÃœR LINIEN
   // Keil-LÃ¤nge in Zeit
   int keilDauer = (int)(wave.p5.time - wave.p1.time);
   datetime greenEnd = wave.p4.time + keilDauer;  // GrÃ¼ne Linie: doppelt so lang wie Keil
   
   // EPA Zeit fÃ¼r rote Linien (Kreuzungspunkt)
   datetime epaTime = wave.epaTime;
   
   //--- KEIL-LINIE 1-3 (rot, nur bis EPA)
   double slope13 = (wave.p3.price - wave.p1.price) / (double)(wave.p3.time - wave.p1.time);
   double epaPrice13 = wave.p1.price + slope13 * (double)(epaTime - wave.p1.time);
   ObjectCreate(chartId, prefix+"L13", OBJ_TREND, 0, 
                wave.p1.time, wave.p1.price, 
                epaTime, epaPrice13);
   ObjectSetInteger(chartId, prefix+"L13", OBJPROP_COLOR, clrRed);
   ObjectSetInteger(chartId, prefix+"L13", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"L13", OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(chartId, prefix+"L13", OBJPROP_RAY_RIGHT, false);
   
   //--- KEIL-LINIE 2-4 (rot, nur bis EPA)
   double slope24 = (wave.p4.price - wave.p2.price) / (double)(wave.p4.time - wave.p2.time);
   double epaPrice24 = wave.p2.price + slope24 * (double)(epaTime - wave.p2.time);
   ObjectCreate(chartId, prefix+"L24", OBJ_TREND, 0, 
                wave.p2.time, wave.p2.price, 
                epaTime, epaPrice24);
   ObjectSetInteger(chartId, prefix+"L24", OBJPROP_COLOR, clrRed);
   ObjectSetInteger(chartId, prefix+"L24", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"L24", OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(chartId, prefix+"L24", OBJPROP_RAY_RIGHT, false);
   
   //--- TARGET Linie 1-4 (grÃ¼n, doppelt so lang wie Keil)
   double slope14 = (wave.p4.price - wave.p1.price) / (double)(wave.p4.time - wave.p1.time);
   double greenEndPrice = wave.p1.price + slope14 * (double)(greenEnd - wave.p1.time);
   ObjectCreate(chartId, prefix+"L14", OBJ_TREND, 0, 
                wave.p1.time, wave.p1.price, 
                greenEnd, greenEndPrice);
   ObjectSetInteger(chartId, prefix+"L14", OBJPROP_COLOR, clrGreen);
   ObjectSetInteger(chartId, prefix+"L14", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"L14", OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(chartId, prefix+"L14", OBJPROP_RAY_RIGHT, false);
   
   //--- Punkt Labels
   CreateText(chartId, prefix+"P1", wave.p1.time, wave.p1.price, "1", waveColor);
   CreateText(chartId, prefix+"P2", wave.p2.time, wave.p2.price, "2", waveColor);
   CreateText(chartId, prefix+"P3", wave.p3.time, wave.p3.price, "3", waveColor);
   CreateText(chartId, prefix+"P4", wave.p4.time, wave.p4.price, "4", waveColor);
   CreateText(chartId, prefix+"P5", wave.p5.time, wave.p5.price, "5", waveColor);
   
   //--- BULLISH/BEARISH + Timeframe OBEN (groÃŸ)
   string titel = (wave.isBullish ? "BULLISH" : "BEARISH") + " " + TFToString(wave.timeframe);
   ObjectCreate(chartId, prefix+"Titel", OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(chartId, prefix+"Titel", OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(chartId, prefix+"Titel", OBJPROP_XDISTANCE, 20);
   ObjectSetInteger(chartId, prefix+"Titel", OBJPROP_YDISTANCE, 25);
   ObjectSetString(chartId, prefix+"Titel", OBJPROP_TEXT, titel);
   ObjectSetInteger(chartId, prefix+"Titel", OBJPROP_COLOR, wave.isBullish ? clrGreen : clrRed);
   ObjectSetInteger(chartId, prefix+"Titel", OBJPROP_FONTSIZE, 16);
   ObjectSetString(chartId, prefix+"Titel", OBJPROP_FONT, "Arial Bold");
   
   //--- SYMBOL NAME darunter (gleiche GrÃ¶ÃŸe)
   string symbolName = SymbolInfoString(wave.symbol, SYMBOL_DESCRIPTION);
   if(symbolName == "") symbolName = wave.symbol;  // Fallback
   ObjectCreate(chartId, prefix+"SymbolName", OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(chartId, prefix+"SymbolName", OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(chartId, prefix+"SymbolName", OBJPROP_XDISTANCE, 20);
   ObjectSetInteger(chartId, prefix+"SymbolName", OBJPROP_YDISTANCE, 48);
   ObjectSetString(chartId, prefix+"SymbolName", OBJPROP_TEXT, symbolName);
   ObjectSetInteger(chartId, prefix+"SymbolName", OBJPROP_COLOR, clrBlack);
   ObjectSetInteger(chartId, prefix+"SymbolName", OBJPROP_FONTSIZE, 16);
   ObjectSetString(chartId, prefix+"SymbolName", OBJPROP_FONT, "Arial Bold");
   
   //=== NUR DATUM + BRANDING UNTEN LINKS ===
   //--- Datum im Format DD.MM.YYYY HH:MM (Lokalzeit)
   datetime localTime = TimeLocal();
   MqlDateTime dtLocal;
   TimeToStruct(localTime, dtLocal);
   string datumStr = StringFormat("%02d.%02d.%04d %02d:%02d", 
                     dtLocal.day, dtLocal.mon, dtLocal.year, dtLocal.hour, dtLocal.min);
   
   ObjectCreate(chartId, prefix+"Datum", OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(chartId, prefix+"Datum", OBJPROP_CORNER, CORNER_LEFT_LOWER);
   ObjectSetInteger(chartId, prefix+"Datum", OBJPROP_XDISTANCE, 20);
   ObjectSetInteger(chartId, prefix+"Datum", OBJPROP_YDISTANCE, 30);
   ObjectSetString(chartId, prefix+"Datum", OBJPROP_TEXT, datumStr);
   ObjectSetInteger(chartId, prefix+"Datum", OBJPROP_COLOR, clrGray);
   ObjectSetInteger(chartId, prefix+"Datum", OBJPROP_FONTSIZE, 9);
   
   //--- Branding
   ObjectCreate(chartId, prefix+"Copyright", OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(chartId, prefix+"Copyright", OBJPROP_CORNER, CORNER_LEFT_LOWER);
   ObjectSetInteger(chartId, prefix+"Copyright", OBJPROP_XDISTANCE, 20);
   ObjectSetInteger(chartId, prefix+"Copyright", OBJPROP_YDISTANCE, 12);
   ObjectSetString(chartId, prefix+"Copyright", OBJPROP_TEXT, "wolfewavesignals.com");
   ObjectSetInteger(chartId, prefix+"Copyright", OBJPROP_COLOR, clrGray);
   ObjectSetInteger(chartId, prefix+"Copyright", OBJPROP_FONTSIZE, 8);
   
   //=== PREIS-MARKER ===
   int periodSec = PeriodSeconds(wave.timeframe);
   datetime shortEnd = wave.p5.time + periodSec * 3;  // Kurz: 3 Kerzen fÃ¼r Entry/SL
   
   // TP-Linien bis zum Ende der grÃ¼nen Linie (2x Keil-LÃ¤nge)
   int keilDauerTP = (int)(wave.p5.time - wave.p1.time);
   datetime greenLineEnd = wave.p4.time + keilDauerTP;
   
   //--- Entry (blau) - KURZ
   ObjectCreate(chartId, prefix+"EntryLine", OBJ_TREND, 0, wave.p5.time, wave.entryPrice, shortEnd, wave.entryPrice);
   ObjectSetInteger(chartId, prefix+"EntryLine", OBJPROP_COLOR, clrDodgerBlue);
   ObjectSetInteger(chartId, prefix+"EntryLine", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"EntryLine", OBJPROP_RAY_RIGHT, false);
   ObjectCreate(chartId, prefix+"EntryLbl", OBJ_TEXT, 0, shortEnd, wave.entryPrice);
   ObjectSetString(chartId, prefix+"EntryLbl", OBJPROP_TEXT, " E");
   ObjectSetInteger(chartId, prefix+"EntryLbl", OBJPROP_COLOR, clrDodgerBlue);
   ObjectSetInteger(chartId, prefix+"EntryLbl", OBJPROP_FONTSIZE, 8);
   
   //--- SL (rot) - KURZ
   ObjectCreate(chartId, prefix+"SLLine", OBJ_TREND, 0, wave.p5.time, wave.slPrice, shortEnd, wave.slPrice);
   ObjectSetInteger(chartId, prefix+"SLLine", OBJPROP_COLOR, clrRed);
   ObjectSetInteger(chartId, prefix+"SLLine", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"SLLine", OBJPROP_RAY_RIGHT, false);
   ObjectCreate(chartId, prefix+"SLLbl", OBJ_TEXT, 0, shortEnd, wave.slPrice);
   ObjectSetString(chartId, prefix+"SLLbl", OBJPROP_TEXT, " SL");
   ObjectSetInteger(chartId, prefix+"SLLbl", OBJPROP_COLOR, clrRed);
   ObjectSetInteger(chartId, prefix+"SLLbl", OBJPROP_FONTSIZE, 8);
   
   //--- TP1 (hellgrÃ¼n) - bis Ende grÃ¼ne Linie
   ObjectCreate(chartId, prefix+"TP1Line", OBJ_TREND, 0, wave.p5.time, wave.tp1Price, greenLineEnd, wave.tp1Price);
   ObjectSetInteger(chartId, prefix+"TP1Line", OBJPROP_COLOR, clrLimeGreen);
   ObjectSetInteger(chartId, prefix+"TP1Line", OBJPROP_WIDTH, 1);
   ObjectSetInteger(chartId, prefix+"TP1Line", OBJPROP_STYLE, STYLE_DOT);
   ObjectSetInteger(chartId, prefix+"TP1Line", OBJPROP_RAY_RIGHT, false);
   ObjectCreate(chartId, prefix+"TP1Lbl", OBJ_TEXT, 0, greenLineEnd, wave.tp1Price);
   ObjectSetString(chartId, prefix+"TP1Lbl", OBJPROP_TEXT, "  TP1 " + DoubleToString(wave.tp1Price, 2));
   ObjectSetInteger(chartId, prefix+"TP1Lbl", OBJPROP_COLOR, clrLimeGreen);
   ObjectSetInteger(chartId, prefix+"TP1Lbl", OBJPROP_FONTSIZE, 9);
   
   //--- TP2 (grÃ¼n) - bis Ende grÃ¼ne Linie
   ObjectCreate(chartId, prefix+"TP2Line", OBJ_TREND, 0, wave.p5.time, wave.tp2Price, greenLineEnd, wave.tp2Price);
   ObjectSetInteger(chartId, prefix+"TP2Line", OBJPROP_COLOR, clrGreen);
   ObjectSetInteger(chartId, prefix+"TP2Line", OBJPROP_WIDTH, 1);
   ObjectSetInteger(chartId, prefix+"TP2Line", OBJPROP_STYLE, STYLE_DOT);
   ObjectSetInteger(chartId, prefix+"TP2Line", OBJPROP_RAY_RIGHT, false);
   ObjectCreate(chartId, prefix+"TP2Lbl", OBJ_TEXT, 0, greenLineEnd, wave.tp2Price);
   ObjectSetString(chartId, prefix+"TP2Lbl", OBJPROP_TEXT, "  TP2 " + DoubleToString(wave.tp2Price, 2));
   ObjectSetInteger(chartId, prefix+"TP2Lbl", OBJPROP_COLOR, clrGreen);
   ObjectSetInteger(chartId, prefix+"TP2Lbl", OBJPROP_FONTSIZE, 9);
   
   //--- TP3 (dunkelgrÃ¼n) - GENAU AUF DER GRÃœNEN LINIE
   // TP3 endet dort wo die grÃ¼ne Linie endet
   ObjectCreate(chartId, prefix+"TP3Line", OBJ_TREND, 0, wave.p5.time, wave.tp3Price, greenLineEnd, wave.tp3Price);
   ObjectSetInteger(chartId, prefix+"TP3Line", OBJPROP_COLOR, clrDarkGreen);
   ObjectSetInteger(chartId, prefix+"TP3Line", OBJPROP_WIDTH, 2);
   ObjectSetInteger(chartId, prefix+"TP3Line", OBJPROP_STYLE, STYLE_DASH);
   ObjectSetInteger(chartId, prefix+"TP3Line", OBJPROP_RAY_RIGHT, false);
   ObjectCreate(chartId, prefix+"TP3Lbl", OBJ_TEXT, 0, greenLineEnd, wave.tp3Price);
   ObjectSetString(chartId, prefix+"TP3Lbl", OBJPROP_TEXT, "  TP3 " + DoubleToString(wave.tp3Price, 2));
   ObjectSetInteger(chartId, prefix+"TP3Lbl", OBJPROP_COLOR, clrDarkGreen);
   ObjectSetInteger(chartId, prefix+"TP3Lbl", OBJPROP_FONTSIZE, 9);
   ObjectSetString(chartId, prefix+"TP3Lbl", OBJPROP_FONT, "Arial Bold");
}

//+------------------------------------------------------------------+
void CreateLine(long chartId, string name, datetime t1, double p1, 
                datetime t2, double p2, color clr, int width, 
                ENUM_LINE_STYLE style = STYLE_SOLID)
{
   ObjectCreate(chartId, name, OBJ_TREND, 0, t1, p1, t2, p2);
   ObjectSetInteger(chartId, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(chartId, name, OBJPROP_WIDTH, width);
   ObjectSetInteger(chartId, name, OBJPROP_STYLE, style);
   ObjectSetInteger(chartId, name, OBJPROP_RAY_RIGHT, false);
}

//+------------------------------------------------------------------+
void CreateText(long chartId, string name, datetime time, double price, 
                string text, color clr)
{
   ObjectCreate(chartId, name, OBJ_TEXT, 0, time, price);
   ObjectSetString(chartId, name, OBJPROP_TEXT, " " + text);
   ObjectSetInteger(chartId, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(chartId, name, OBJPROP_FONTSIZE, 12);
   ObjectSetString(chartId, name, OBJPROP_FONT, "Arial Bold");
}

//+------------------------------------------------------------------+
void CreateTextSmall(long chartId, string name, datetime time, double price, 
                     string text, color clr)
{
   ObjectCreate(chartId, name, OBJ_TEXT, 0, time, price);
   ObjectSetString(chartId, name, OBJPROP_TEXT, text);
   ObjectSetInteger(chartId, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(chartId, name, OBJPROP_FONTSIZE, 8);
   ObjectSetString(chartId, name, OBJPROP_FONT, "Arial");
}

//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
   if(id == CHARTEVENT_KEYDOWN)
   {
      if(lparam == 'S')
      {
         Print(">>> MANUELLER SCAN <<<");
         PerformScan();
      }
      if(lparam == 'C')
      {
         Print("SchlieÃŸe alle Charts...");
         for(int i = 0; i < ArraySize(g_openCharts); i++)
            ChartClose(g_openCharts[i]);
         ArrayResize(g_openCharts, 0);
      }
      if(lparam == 'T')
      {
         Print(">>> SUCCESS TRACKING <<<");
         CheckSuccessSignals();
      }
   }
}

//+------------------------------------------------------------------+
void OnTick() { }

//+------------------------------------------------------------------+
//| ERFOLGS-TRACKING: PrÃ¼ft ob alte Signale TP3 erreicht haben       |
//+------------------------------------------------------------------+
void CheckSuccessSignals()
{
   Print("");
   Print("========== SUCCESS CHECK ==========");
   
   // SUCCESS Ordner erstellen
   FolderCreate("WolfeWaves\\SUCCESS");
   
   string basePath = "WolfeWaves\\";
   string markets[] = {"DAX", "NASDAQ", "NYSE", "SP500", "FOREX", "CAC40", "FTSE", "OTHER"};
   string timeframes[] = {"M5", "M15", "H1", "H4", "D1", "W1"};
   
   int successCount = 0;
   int checkedCount = 0;
   
   // Ordner durchsuchen
   for(int m = 0; m < ArraySize(markets); m++)
   {
      for(int t = 0; t < ArraySize(timeframes); t++)
      {
         string searchPath = basePath + markets[m] + "\\" + timeframes[t] + "\\";
         
         string folderName;
         long searchHandle = FileFindFirst(searchPath + "*", folderName);
         
         if(searchHandle != INVALID_HANDLE)
         {
            do
            {
               if(folderName == "." || folderName == "..") continue;
               
               string fullFolderPath = searchPath + folderName + "\\";
               string jsonPath = fullFolderPath + "latest.json";
               string pngPath = fullFolderPath + "latest.png";
               
               // PrÃ¼fe ob JSON existiert
               if(FileIsExist(jsonPath))
               {
                  checkedCount++;
                  
                  // JSON lesen und TP3-Check durchfÃ¼hren
                  bool tp3Reached = CheckSignalTP3(jsonPath);
                  
                  if(tp3Reached)
                  {
                     successCount++;
                     
                     // In SUCCESS Ordner kopieren
                     string successFolder = "WolfeWaves\\SUCCESS\\" + folderName + "\\";
                     
                     // Nur kopieren wenn noch nicht vorhanden
                     if(!FileIsExist(successFolder + "latest.json"))
                     {
                        FolderCreate("WolfeWaves\\SUCCESS\\" + folderName);
                        CopyFileInternal(jsonPath, successFolder + "latest.json");
                        CopyFileInternal(pngPath, successFolder + "latest.png");
                        Print("âœ… SUCCESS: ", folderName, " - TP3 erreicht!");
                     }
                  }
               }
            }
            while(FileFindNext(searchHandle, folderName));
            
            FileFindClose(searchHandle);
         }
      }
   }
   
   Print("");
   Print("ðŸ“Š ERGEBNIS:");
   Print("   GeprÃ¼ft: ", checkedCount, " Signale");
   Print("   TP3 erreicht: ", successCount);
   Print("====================================");
}

//+------------------------------------------------------------------+
void CopyFileInternal(string source, string dest)
{
   if(!FileIsExist(source)) return;
   
   int srcHandle = FileOpen(source, FILE_READ|FILE_BIN);
   if(srcHandle == INVALID_HANDLE) return;
   
   int fileSize = (int)FileSize(srcHandle);
   uchar data[];
   ArrayResize(data, fileSize);
   FileReadArray(srcHandle, data);
   FileClose(srcHandle);
   
   int dstHandle = FileOpen(dest, FILE_WRITE|FILE_BIN);
   if(dstHandle != INVALID_HANDLE)
   {
      FileWriteArray(dstHandle, data);
      FileClose(dstHandle);
   }
}

//+------------------------------------------------------------------+
bool CheckSignalTP3(string jsonPath)
{
   // JSON einlesen
   int fileHandle = FileOpen(jsonPath, FILE_READ|FILE_TXT|FILE_ANSI);
   if(fileHandle == INVALID_HANDLE) return false;
   
   string jsonContent = "";
   while(!FileIsEnding(fileHandle))
      jsonContent += FileReadString(fileHandle);
   FileClose(fileHandle);
   
   // Werte parsen
   string symbol = ExtractJsonValue(jsonContent, "symbol");
   string timeframe = ExtractJsonValue(jsonContent, "timeframe");
   double tp3 = StringToDouble(ExtractJsonValue(jsonContent, "tp3"));
   string direction = ExtractJsonValue(jsonContent, "direction");
   
   if(symbol == "" || tp3 == 0) return false;
   
   // Timeframe konvertieren
   ENUM_TIMEFRAMES tf = StringToTF(timeframe);
   
   // Historische Daten laden
   MqlRates rates[];
   ArraySetAsSeries(rates, true);
   int copied = CopyRates(symbol, tf, 0, 200, rates);
   
   if(copied < 10) return false;
   
   bool isBullish = (direction == "BULLISH");
   
   // PrÃ¼fe ob TP3 erreicht wurde
   for(int i = copied - 1; i >= 0; i--)
   {
      if(isBullish)
      {
         if(rates[i].high >= tp3) return true;  // TP3 erreicht!
      }
      else
      {
         if(rates[i].low <= tp3) return true;   // TP3 erreicht!
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
string ExtractJsonValue(string json, string key)
{
   string searchKey = "\"" + key + "\":";
   int pos = StringFind(json, searchKey);
   if(pos < 0) return "";
   
   pos += StringLen(searchKey);
   
   // Whitespace Ã¼berspringen
   while(pos < StringLen(json) && (StringGetCharacter(json, pos) == ' ' || StringGetCharacter(json, pos) == '\t'))
      pos++;
   
   // Wert extrahieren
   string value = "";
   bool inQuotes = false;
   
   if(StringGetCharacter(json, pos) == '"')
   {
      inQuotes = true;
      pos++;
   }
   
   while(pos < StringLen(json))
   {
      ushort ch = StringGetCharacter(json, pos);
      
      if(inQuotes && ch == '"') break;
      if(!inQuotes && (ch == ',' || ch == '}' || ch == '\n')) break;
      
      value += CharToString((uchar)ch);
      pos++;
   }
   
   return value;
}

//+------------------------------------------------------------------+
ENUM_TIMEFRAMES StringToTF(string tf)
{
   if(tf == "M5") return PERIOD_M5;
   if(tf == "M15") return PERIOD_M15;
   if(tf == "H1") return PERIOD_H1;
   if(tf == "H4") return PERIOD_H4;
   if(tf == "D1") return PERIOD_D1;
   if(tf == "W1") return PERIOD_W1;
   return PERIOD_H1;
}
//+------------------------------------------------------------------+
